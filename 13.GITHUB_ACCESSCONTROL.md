# Introduction
GitHub's access control is a powerful, hierarchical system built around organizations, teams, and repositories. Permissions are managed using roles, with the principle of least privilege as a best practice to ensure users have only the access they need.

## Organizational Level Access
The highest level of control is at the organization, which contains members, teams, and repositories.

**Owners**: Have full administrative control over the entire organization and all its repositories and settings. To ensure continuity, it is recommended to have at least two owners.

**Members**: The default, non-administrative role. Members' access is configurable by owners.

**Billing Managers**: Can manage the organization's billing settings but have no access to code or other technical resources.

**Outside Collaborators**: People who are not members of the organization but are granted access to specific repositories. Their permissions are limited and controlled at the repository level.

## Repository Level Access
At the repository level, granular roles define what a user or team can do.

**Read**: Provides read-only access to the repository's content, issues, and pull requests.

**Triage**: Can proactively manage issues and pull requests, such as labeling and assigning, but cannot modify repository content.

**Write**: Grants write permissions, allowing users to merge pull requests and create releases.

**Maintain**: Grants broad access to the repository but excludes high-risk actions like deleting the repository.

**Admin**: Provides full control over the repository, including managing security settings and deleting the repository.

## Team-based Access
Teams are groups of organization members that streamline permission management.

**Access management**: Instead of assigning permissions to individuals for multiple repositories, you assign a role to a team for a specific repository. All members of that team automatically inherit those permissions.

**Inheritance**: Teams can be nested to reflect your company's hierarchy. Child teams automatically inherit the permissions of their parent teams.

**Team Maintainers**: Within a team, a user can be assigned the Team Maintainer role, giving them administrative permissions over that team's settings and membership.

## Best practices

**Use teams for scale**: Always use teams for group access rather than adding many individual collaborators. It simplifies management and auditing.

**Principle of least privilege**: Grant the minimum level of access required to perform a task. Avoid giving users Admin or Maintain roles when a Write role is sufficient.

**Review access regularly**: Periodically audit the access list for your repositories to ensure permissions are up-to-date, especially when employees change roles or leave the company.

**Leverage branch protection**: For critical branches like main, use branch protection rules to enforce merge requirements, like requiring pull request reviews. This provides an additional layer of security.

## Where to Control Access?
**_Navigation_**: Settings > Collaborators & Teams

From the "Collaborators & Teams" page, you can add user, create teams, and give both Repository Level and Organization Level Access.

## Controlling Repository-Level Access Programatically

**Step1**: Create a file .github/access-control/acl.yml within your individual repo and define your repo-level access.
```yml
configuration:
  manageAccess:
    - member: bm80177
      role: admin   # Roles: admin, maintain, write, triage, read
    - member: v-bimishra
      role: maintain
    - member: mishrabp
      role: admin
```

**Step2**: A python program .github/access-control/apply-acl.py to apply the acl.yml changes into the repo.
```py
import os
import yaml
import requests

def main():
    # Load ACL YAML
    with open(".github/access-control/acl.yaml", "r") as f:
        acl = yaml.safe_load(f)

    repo_owner, repo_name = os.getenv("GITHUB_REPOSITORY").split("/")
    token = os.getenv("GITHUB_TOKEN")

    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github+json"
    }

    for entry in acl.get("configuration", {}).get("manageAccess", []):
        username = entry["member"]
        role = entry["role"].lower()
        url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/collaborators/{username}"
        payload = {"permission": role}

        response = requests.put(url, headers=headers, json=payload)
        if response.status_code in [201, 204]:
            print(f"Set {username} permission to {role} successfully.")
        else:
            print(f"Failed to set {username}: {response.status_code} - {response.text}")

if __name__ == "__main__":
    main()
```

**Step3**: Define a workflow .github/workflows/apply-acl.yml that triggers the python program.
```yml
name: Apply ACL

on:
  push:
    paths:
      - '.github/access-control/acl.yaml'

jobs:
  apply-acl:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install requests pyyaml

      - name: Apply Access Control from acl.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          python .github/access-control/apply_acl.py
```



